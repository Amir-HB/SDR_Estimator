# Import libraries for Tukey's median
library(TukeyRegion)

# Import for plotting with colors
library(RColorBrewer)

# This computes the norm 2 of a given vector
norm2 <-function(x){
  return(sqrt(sum(x*x)))
}

# This function applies each estimator in "estimators" on a "eps"-contaminated 
# data of size "n", dimension "p", generated by the scheme indicated in "contamination"
# Output is a matrix containing loss and running time for each estimator
experiment <- function(n,p,eps,Sigma,contamination,estimators){
	
	if (contamination == "flip"){
		X = flipping_contam(n, p, eps, Sigma)
	}
	else if (contamination == "unif"){
		X = generate_X(n, p, eps, Sigma, outlier_type="large") 
	}
	else if(contamination == "mixt") {
		X = mixture(n,p,eps,15)
	}
	else if(contamination == "scat") {
		X = scattered_contam(n,p,eps,Sigma,6)
	}
	else{ 
		stop("Invalid contamination: ",contamination)
	}
	
	l = c()
	t = c()
	for (name in estimators){
		cat(" **  ",name,"for n = ",n, " p = ",p," epsilon= ",eps," ...\n")
		if(name=="SDR"){
			# delta is the max probabilty that the theoretical risk boound is not satisfied
			delta = .1
			# eps_star is the maximum value for eps and should be smaller than 1/2
			# if eps is known it is recommended to set eps_star=eps
			eps_star = eps
			
			rn = (sqrt(p) + sqrt(2*log(2/delta)))/sqrt(n)
	  		tau = min(0.25, rn/sqrt(log(2/rn)))
	  		# tau is a tuning parameter
	  		thresh = (1+rn)/sqrt(1-2*eps_star)
	  		thresh = thresh + 1 + 4*(rn/sqrt(tau) + sqrt(2+2*log(1/tau)))
	  
	  		#mu = mu_SDR(X, 1+ 0.05*(thresh-1),Sigma)
	  		start_time <- Sys.time()
	  		mu = mu_SDR(X,thresh,Sigma)
	  		end_time <- Sys.time()
			t_1 = end_time-start_time
			cat(" **  ",name," done in ", t_1," seconds for n = ",n, " p = ",p," epsilon= ",eps, "\n")
			l_1 = norm2(mu)
			l = c(l,l_1)
			t = c(t,t_1)
		}	
		else if (name=="Iterative reweighting"){
			start_time <- Sys.time()
			mu_hat <- mu_IR(X, eps, Sigma)
			end_time <- Sys.time()
			t_2 = end_time-start_time
			cat(" **  ",name," done in ", t_2," seconds for n = ",n, " p = ",p," epsilon= ",eps, "\n")
			l_2 = norm2(mu_hat)
			l = c(l,l_2)
			t = c(t,t_2)
		}
		else if (name=="Iterative filtering"){
			start_time <- Sys.time()
			mu_itvf = ItvFiltering(X,eps,.1,2.5)
			l_3 = norm2(mu_itvf)	
			end_time <- Sys.time()
			t_3 = end_time-start_time
			cat(" ** ",name," done in ", t_3," seconds for n = ",n, " p = ",p," epsilon= ",eps, "\n")
			l_3 = norm2(mu_itvf)
			l = c(l,l_3)
			t = c(t,t_3)
		}
		else if (name=="Geometric median"){
			start_time <- Sys.time()
			#gm = geo_median(X,tol=1e01,maxiter=15)$p	
			gm = geo_median(X)$p	
			end_time <- Sys.time()
			t_4 = end_time-start_time
			cat(" **  ",name," done in ", t_4," seconds for n = ",n, " p = ",p," epsilon= ",eps, "\n")
			l_4 = norm2(gm)
			l = c(l,l_4)
			t = c(t,t_4)
		}
		else if (name=="Oracle"){
			start_time <- Sys.time()
			oracle = colMeans(X[1:floor((1-eps)*n),])
			end_time <- Sys.time()
			t_5 = end_time-start_time
			cat(" ** ",name," done in ", t_5," seconds for n = ",n, " p = ",p," epsilon= ",eps, "\n")
			l_5 = norm2(oracle)
			l = c(l,l_5)
			t = c(t,t_5)
		}
		else if (name=="Sample mean"){
			start_time <- Sys.time()
			mu_bar = colMeans(X)
			end_time <- Sys.time()
			t_6 = end_time-start_time
			cat(" **  ",name, " done in ", t_6," seconds for n = ",n, " p = ",p," epsilon= ",eps, "\n")
			l_6 = norm2(mu_bar)
			l = c(l,l_6)
			t = c(t,t_6)
		}
		else if (name=="Tukey's median"){
			if (n^p>10^10) {
				warning("It is not a good idea to compute Tukey's medain for such parameters"," n=",n," p=",p)
				l_7 = 0
				t_7 = 0
			}
			else{
				start_time <- Sys.time()
				mu_tuk = TukeyMedian(X)$barycenter
				end_time <- Sys.time()
				t_7 = end_time-start_time
				cat(" **  ",name," done in ", t_7," seconds for n = ",n, " p = ",p," epsilon= ",eps, "\n")
				l_7 = norm2(mu_tuk)
			}
			l = c(l,l_7)
			t = c(t,t_7)
		}
		#else if (name=="New iterative reweighting"){
		#	start_time <- Sys.time()
		#	mu_hat <- new_mu_IR(X, eps, Sigma)
		#	end_time <- Sys.time()
		#	t_8 = end_time-start_time
		#	cat(" **  ",name," done in ", t_8," seconds for n = ",n, " p = ",p," epsilon= ",eps, "\n")
		#	l_8 = norm2(mu_hat)
		#	l = c(l,l_8)
		#	t = c(t,t_8)
		#}
		else if (name=="Componentwise median"){
			start_time <- Sys.time()
			#eigs = eigen(cov(X))
			#U = eigs$vectors
			#X = X %*% U
			mu_hat <- apply(X,2,median)
			end_time <- Sys.time()
			t_9 = end_time-start_time
			cat(" **  ",name," done in ", t_9," seconds for n = ",n, " p = ",p," epsilon= ",eps, "\n")
			print(mu_hat)
			l_9 = norm2(mu_hat)
			l = c(l,l_9)
			t = c(t,t_9)
		}
		else {stop("Invalid estimator: ",name)}
	}
	return(rbind(l,log(t)))
}	

# This function repeat 	"rep_num" times the function experiment
# Output is a matrix contaiing the average and standard deviation for loss
# and running time of each estimator
experiment_repeat <- function(n,p,eps,Sigma,rep_num,contamination,estimators){
	l = c(seq(1,rep_num))
	l = sapply(l, (function (i) experiment(n,p,eps,Sigma,contamination,estimators)))
	#print(l)
	#M=rbind(rowMeans(l),apply(l,1,sd))
	M=rbind(apply(l,1,(function (x) quantile(x,probs=c(0.25,0.5,0.75)))))
	#print(M)
	return(M)
}	

# This function variates "parameter" over "range" under the given set-up and 
# returns loss and running time of estimators
variation <- function(n,p,eps,Sigma,parameter,range,rep_num,contamination,estimators){
	if (parameter=="n"){
		loss = sapply(range, (function (n) 
					experiment_repeat(n,p,eps,Sigma,rep_num,contamination,estimators)))
		xlab="sample size"		
	}
	else if (parameter=="p"){
		loss = sapply(range, (function (p) 
					experiment_repeat(n,p,eps,diag(p),rep_num,contamination,estimators)))
		xlab="dimension"
	}
	else if (parameter=="eps"){
		loss = sapply(range, (function (eps) 
					experiment_repeat(#10*floor(p/eps^2),
							n,p,eps,Sigma,rep_num,contamination,estimators)))
		xlab="epsilon"		
	}
	else {stop("Invalid paramter: ",parameter)}
	
	return(loss)
}

